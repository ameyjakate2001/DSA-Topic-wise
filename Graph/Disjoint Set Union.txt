 
   Disjoint Set Union :- 
     When there are single nodes, and then they get connected and made groups then DSU will be useful.
    
     The main concept is firstly we assume them as a alone, and when they are alone their parents are themselves..
     ex:- for nodes 1, 2, 3, 4, 5 their parent are 1,2,3,4,5 respectively.

     so, let's say when we join 1-2 then what we do is 
       1] we find parent of both 1 and 2 and just make any one's parent to another.
    
     Two Steps :- 1) Find Parent  2) make Union

 
     we will use parent array for storing parents ,
       int p[n+1] and start with themseleves as their parents.
     
     1  1  1  4  4
     1--2--3  4--5

     Now, when 3 and 4 get connected then,
     fp4 = 4 and fp3 = 1
     then, we will make, 
      p4 = 1;
   
     1  1  1  1  4
     1--2--3  4--5

     and now, when we go to ** line of code then when we try to find the parent 
     of 5 then, 4 will not be the parent of 5 
     f_p(5) => f_p(4) => f_p(3)
      1 <=         1 <=      <= 1

     so, remember p will always save the immediate parent not global parent.
     
    Code:-
      n=nodes, k=relations, x&y= to join
       int p[n+1];
       int main() {
          int n,k,x,y; 
          cin>>n>>k;
          for(int i=1;i<=n;i++) {
             p[i]=i;
          }
           for(int i=0;i<k;i++) {
             cin>>x>>y;

             Union_set(x,y);
          }
          
          //Here we are finding the global parent for the node
          //and then checking how many parent we have
          
          set<int>s;
          for(int i=1;i<=n;i++) { 
     ********  s.insert(find_parent(i));
          }
          cout<<s.size();
       }

       void Union_set(int x, int y) {
          int fpx = find_parent(x);
          int fpy = find_parent(y);
          
          if(fpx == fpy) return;
        
          p[y] = fpx;
       }

      // This will be recursive method
      int find_parent(int node) {
         if(p[node] == node) 
           return node;
        
         int parent = find_parent(p[node]);
   
         return parent;
      }

      and one Important optimisation we can do is , 
         when we get the parent at find_parent() then we save that answer in the parent array
        
         and this is called DP.

        int find_parent(int node) {
         if(p[node] == node) 
           return node;
        
         int parent = find_parent(p[node]);
         p[node] = parent;
   
         return parent;
      }



